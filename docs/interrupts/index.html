<!DOCTYPE html>

<html lang="en">
<head>
<meta charset="utf-8"/>
<meta content="width=device-width, initial-scale=1.0" name="viewport"/>
<title>Handling Interrupts</title>
<link href="../static/favicon.ico" rel="icon" type="image/x-icon"/>
<link href="../static/page.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<nav>
<a href="../">Home</a>
      ·
      <span class="dropdown">
<a href="#">Lessons</a>
<span class="dropdown-content" id="nav-lessons">
<a href="../intro/">Introduction</a>
<a href="../des/">Discrete Event Simulation</a>
<a href="../metrics/">Simple Metrics</a>
<a href="../scenarios/">Exploring Scenarios</a>
<a href="../interrupts/">Handling Interrupts</a>
<a href="../insight/">Insights</a>
<a href="../finale/">Conclusion</a>
</span>
</span>
      ·
      <span class="dropdown">
<a href="#">Appendices</a>
<span class="dropdown-content" id="nav-appendices">
<a href="../license/">License</a>
<a href="../conduct/">Code of Conduct</a>
<a href="../contributing/">Contributing</a>
<a href="../bibliography/">Bibliography</a>
<a href="../glossary/">Glossary</a>
</span>
</span>
</nav>
<main>
<h1>Handling Interrupts</h1>
<h2>Throwing Work Away</h2>
<ul>
<li>Jobs don't have priorities</li>
<li>The manager interrupts</li>
<li>Any work done on the current job is lost<ul>
<li>We'll fix this later</li>
</ul>
</li>
<li>Parameters and simulation class</li>
</ul>
<pre class="language-python"><code class="language-python" data-file="discard.py">class Params:
    …as before…
    t_interrupt_arrival: float = 5.0

class Simulation(Environment):
    …as before…
    def rand_interrupt_arrival(self):
        return random.expovariate(1.0 / self.params.t_interrupt_arrival)
</code></pre>
<ul>
<li>But we need a way to get at the coder's process (i.e., the generator) in order to interrupt it<ul>
<li>The <code>Coder</code> instance is something we've built around the generator</li>
<li><code>Environment.process(…)</code> returns the generator, so we can store that</li>
</ul>
</li>
</ul>
<pre class="language-python"><code class="language-python" data-file="discard.py">class Simulation(Environment):
    def simulate(self):
        …queue, manager, and monitor as before…

        self.process(Interrupter(self).run())

        self.coders = []
        for _ in range(self.params.n_coder):
            coder = Coder(self)
            coder.proc = self.process(coder.run())
            self.coders.append(coder)

        self.run(until=self.params.t_sim)
</code></pre>
<ul>
<li>Our new <code>Interrupter</code> reaches inside a coder to get its process</li>
</ul>
<pre class=""><code data-file="discard.py">class Interrupter(Recorder):
    def run(self):
        while True:
            yield self.sim.timeout(self.sim.rand_interrupt_arrival())
            coder = random.choice(self.sim.coders)
            coder.proc.interrupt()
</code></pre>
<div class="callout">
<ul>
<li>When we call <code>proc.interrupt()</code>, SimPy raises an <code>Interrupt</code> exception inside the generator</li>
<li>But it can only do this while the framework is running, <em>not</em> while the process is running<ul>
<li>Because only one thing runs at a time</li>
</ul>
</li>
<li>So the exception is only raised when the process interacts with the environment<ul>
<li>I.e., at <code>queue.get()</code>, <code>timeout()</code>, or other <code>yield</code> points</li>
</ul>
</li>
</ul>
</div>
<ul>
<li>Write a <code>Coder</code> that throws away whatever job it's doing when it is interrupted<ul>
<li>Not realistic, but it gives us a chance to learn about interrupts</li>
</ul>
</li>
</ul>
<pre class=""><code data-file="discard.py">from simpy import Interrupt

class Coder(Recorder):
    def run(self):
        while True:
            try:
                job = yield self.sim.queue.get()
                job.t_start = self.sim.now
                yield self.sim.timeout(job.duration)
                job.t_end = self.sim.now
                self.t_work += job.t_end - job.t_start
            except Interrupt:
                self.n_interrupt += 1
                job.t_end = self.sim.now
                job.discarded = True
            self.t_work += job.t_end - job.t_start
</code></pre>
<ul>
<li>Exercise: how does the percentage of discarded jobs change as the interrupt rate changes?</li>
</ul>
<h2>Resuming Work</h2>
<ul>
<li>General idea: coders have a stack of work<ul>
<li>At most one regular job</li>
<li>And zero or more interrupts stacked on top of it</li>
<li>When an interrupt arrives, it goes on the top of the stack</li>
</ul>
</li>
<li>Do the simple bits first<ul>
<li>Subclass <code>Job</code> so that we can call different methods for defining duration</li>
</ul>
</li>
<li>Notice that we're piling up a bunch of parameters whose values we probably don't know</li>
</ul>
<pre class=""><code data-file="interrupts.py">class Params:
    …as before…
    t_interrupt_arrival: float = 5.0
    t_interrupt_mean: float = 0.2
    t_interrupt_std: float = 0.1

class JobRegular(Job):
    def __init__(self, sim):
        super().__init__(sim)
        self.duration = self.sim.rand_job_duration()


class JobInterrupt(Job):
    def __init__(self, sim):
        super().__init__(sim)
        self.duration = self.sim.rand_interrupt_duration()
</code></pre>
<ul>
<li><code>Manager</code> creates <code>JobRegular</code>, <code>Interrupter</code> creates <code>JobInterrupt</code></li>
<li>Note that <code>Interrupter</code> passes the new job to <code>.interrupt()</code> so that it becomes the exception's <code>.cause</code></li>
</ul>
<pre class=""><code data-file="interrupts.py">class Interrupter(Recorder):
    def run(self):
        while True:
            yield self.sim.timeout(self.sim.rand_interrupt_arrival())
            coder = random.choice(self.sim.coders)
            coder.proc.interrupt(JobInterrupt(self.sim))
</code></pre>
<ul>
<li>It took several tries to get the <code>Coder</code> right</li>
<li>The problem is that interrupts can occur whenever the coder interacts with SimPy<ul>
<li>So if the coder does anything with SimPy in the <code>except</code> block,
    we can have an interrupt while we're handling an interrupt</li>
</ul>
</li>
<li>Solution is to implement a <a href="../glossary/#state-machine">state machine</a><ol>
<li>No work, so get a new job from the coding queue.</li>
<li>Job on top of the stack is incomplete, so do some work.</li>
<li>Job on top of the stack is complete, so pop it.</li>
</ol>
</li>
<li>If an interrupt occurs:<ul>
<li>Add some time to the current job <em>if we actually started it</em></li>
<li>Push the new job on the stack</li>
<li>Note: the new job arrives as the <code>Interrupt</code> exception's cause</li>
</ul>
</li>
</ul>
<pre class=""><code data-file="interrupts.py">class Coder(Recorder):
    def __init__(self, sim):
        super().__init__(sim)
        self.proc = None
        self.stack = []

    def run(self):
        while True:
            started = None
            try:
                # No work in hand, so get a new job.
                if len(self.stack) == 0:
                    job = yield self.sim.code_queue.get()
                    job.start()
                    self.stack.append(job)
                # Current job is incomplete, so try to finish it.
                elif self.stack[-1].done &lt; self.stack[-1].duration:
                    job = self.stack[-1]
                    started = self.sim.now
                    yield self.sim.timeout(job.duration - job.done)
                    job.done = job.duration
                # Current job is complete.
                else:
                    job = self.stack.pop()
                    job.complete()
            except Interrupt as exc:
                # Some work has been done on the current job, so save it.
                if (len(self.stack) &gt; 0) and (started is not None):
                    now = self.sim.now
                    job = self.stack[-1]
                    job.interrupt()
                    job.done += now - started
                # Put the interrupting job on the stack.
                job = exc.cause
                job.start()
                self.stack.append(job)
</code></pre>
<ul>
<li>This works, but the code is hard to understand, debug, and extend</li>
</ul>
<h2>Decomposing Jobs</h2>
<ul>
<li>Design has two parts:<ul>
<li>Treat interrupts as high-priority jobs</li>
<li>Break regular jobs into short fragments so that interrupts are handled promptly (but not immediately)</li>
</ul>
</li>
<li>Define three priorities:<ul>
<li>High: interrupt</li>
<li>Medium: fragments of regular job</li>
<li>Low: regular jobs</li>
</ul>
</li>
</ul>
<pre class=""><code data-file="decompose.py">class Priority:
    HIGH = 0
    MEDIUM = 1
    LOW = 2
</code></pre>
<ul>
<li>Generic <code>Job</code> has a few <a href="../glossary/#lifecycle-method">lifecycle methods</a> for child classes to override<ul>
<li><code>Job.start</code> is called when work starts on a job</li>
<li><code>Job.complete</code> is called when the job is completed</li>
<li><code>Job.is_complete</code> tells us whether the job has been completed or not</li>
<li><code>Job.needs_decomp</code> tells us whether the job needs to be decomposed</li>
</ul>
</li>
<li>We will explain <code>sim.do_nothing()</code> shortly</li>
</ul>
<pre class=""><code data-file="decompose.py">class Job(Recorder):
    def __init__(self, sim, priority):
        super().__init__(sim)
        self.priority = priority
        self.t_create = self.sim.now
        self.t_start = None
        self.t_complete = None

    def start(self):
        self.t_start = self.sim.now

    def complete(self):
        self.t_complete = self.sim.now
        return self.sim.do_nothing()

    def is_complete(self):
        return self.t_complete is not None

    def needs_decomp(self):
        return False

    def __lt__(self, other):
        if self.priority == other.priority:
            return self.t_create &lt; other.t_create
        return self.priority &lt; other.priority
</code></pre>
<ul>
<li><code>JobInterrupt</code> is the simplest child class</li>
</ul>
<pre class=""><code data-file="decompose.py">class JobInterrupt(Job):
    def __init__(self, sim):
        super().__init__(sim, Priority.HIGH)
        self.duration = self.sim.rand_interrupt_duration()
</code></pre>
<ul>
<li><code>JobRegular</code> overrides <code>.needs_decomp()</code><ul>
<li>If this job isn't complete <em>and</em> the time required is greater than the decomposition threshold</li>
<li>The latter parameter is another completely arbitrary number</li>
</ul>
</li>
</ul>
<pre class=""><code data-file="decompose.py">class JobRegular(Job):
    def __init__(self, sim):
        super().__init__(sim, Priority.LOW)
        self.duration = self.sim.rand_job_duration()

    def needs_decomp(self):
        return (not self.is_complete()) and (self.duration &gt; self.sim.params.t_decomposition)
</code></pre>
<ul>
<li><code>JobFragment</code> is the most complex<ul>
<li>Duration is specified by its creator (part of the total time required by a regular job)</li>
<li>And it has a reference to a placeholder that keeps track of undone fragments</li>
</ul>
</li>
<li>When then fragment is completed, it checks to see if it is the last one in its group<ul>
<li>If so, it bumps the priority of the completed job to medium and puts it back in the coder's queue</li>
<li>If not, it does nothing</li>
</ul>
</li>
</ul>
<pre class=""><code data-file="decompose.py">class JobFragment(Job):
    def __init__(self, coder, placeholder, duration):
        super().__init__(coder.sim, Priority.MEDIUM)
        self.coder = coder
        self.placeholder = placeholder
        self.duration = duration

    def complete(self):
        super().complete()
        self.placeholder.count -= 1
        if self.placeholder.count == 0:
            self.placeholder.job.complete()
            self.placeholder.job.priority = Priority.MEDIUM
            return self.coder.queue.put(self.placeholder.job)
        else:
            return self.sim.do_nothing()
</code></pre>
<div class="callout">
<ul>
<li>When <code>.complete</code> wants to put the original (regular) job back in the coder's queue,
    it would be natural to call <code>yield self.code.queue.put(…)</code></li>
<li>But what if it doesn't?</li>
<li>Solution:<ul>
<li><code>.complete</code> always returns something that can be yielded</li>
<li>Either "put this job in queue" <em>or</em> "wait for 0 ticks"</li>
</ul>
</li>
</ul>
<pre class=""><code data-file="decompose.py">class Simulation(Environment):
    def do_nothing(self):
        return self.timeout(0)
</code></pre>
</div>
<ul>
<li><code>Coder.run</code> gets a job from the general "new work" queue or from its priority queue<ul>
<li>Gives preference to the latter so that interrupts and fragments are done before regular work</li>
<li>Always yields result of <code>job.complete()</code></li>
</ul>
</li>
</ul>
<pre class=""><code data-file="decompose.py">    def run(self):
        while True:
            job = yield from self.get()
            job.start()
            if job.needs_decomp():
                yield from self.decompose(job)
            elif not job.is_complete():
                yield self.sim.timeout(job.duration)
                yield job.complete()
</code></pre>
<ul>
<li>To decompose a job:<ul>
<li>Figure out the durations of the fragments</li>
<li>Create a placeholder to keep track of them and the original job</li>
<li>Put the fragments in the coder's priority queue</li>
</ul>
</li>
</ul>
<pre class=""><code data-file="decompose.py">    def decompose(self, job):
        size = self.sim.params.t_decomposition
        num = int(job.duration / size)
        extra = job.duration - (num * size)
        durations = [extra, *[size for _ in range(num)]]
        placeholder = Placeholder(job=job, count=len(durations))
        for d in durations:
            yield self.queue.put(JobFragment(self, placeholder, d))
</code></pre>
<ul>
<li>So is this better than using interrupts?<ul>
<li>250 lines for decomposition vs. 212 for interrupts</li>
<li>Decomposition approach was a lot simpler to debug</li>
</ul>
</li>
</ul>
</main>
<footer>
<div class="row">
<div class="col-3 left">
	  ⇐ <a href="../scenarios/">Exploring Scenarios</a>
</div>
<div class="col-6 center">
<a href="../"></a>
	  © 2025
	  <a href="../#acknowledgments">the authors</a>
</div>
<div class="col-3 right">
<a href="../insight/">Insights</a> ⇒
	</div>
</div>
</footer>
</body>
</html>