<!DOCTYPE html>

<html lang="en">
<head>
<meta charset="utf-8"/>
<meta content="width=device-width, initial-scale=1.0" name="viewport"/>
<title>Simple Metrics</title>
<link href="../static/favicon.ico" rel="icon" type="image/x-icon"/>
<link href="../static/page.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<nav>
<a href="../">Home</a>
      ·
      <span class="dropdown">
<a href="#">Lessons</a>
<span class="dropdown-content" id="nav-lessons">
<a href="../intro/">Introduction</a>
<a href="../des/">Discrete Event Simulation</a>
<a href="../metrics/">Simple Metrics</a>
<a href="../scenarios/">Exploring Scenarios</a>
<a href="../interrupts/">Handling Interrupts</a>
<a href="../insight/">Insights</a>
<a href="../finale/">Conclusion</a>
</span>
</span>
      ·
      <span class="dropdown">
<a href="#">Appendices</a>
<span class="dropdown-content" id="nav-appendices">
<a href="../license/">License</a>
<a href="../conduct/">Code of Conduct</a>
<a href="../contributing/">Contributing</a>
<a href="../bibliography/">Bibliography</a>
<a href="../glossary/">Glossary</a>
</span>
</span>
</nav>
<main>
<h1>Simple Metrics</h1>
<p id="terms">Terms defined: <a class="term-defined" href="littles-law">Little's Law</a></p>
<h2>Measuring Delay</h2>
<ul>
<li><code>Params</code></li>
</ul>
<pre class=""><code data-file="measure_delay.py">@dataclass_json
@dataclass
class Params:
    t_job_arrival: float = 2.0
    t_job_mean: float = 0.5
    t_job_std: float = 0.6
    t_sim: float = 10
</code></pre>
<ul>
<li><code>Job</code> class keeps track of when it was created, started, and completed<ul>
<li><code>t_start</code> and <code>t_complete</code> may be null</li>
</ul>
</li>
<li>Newly-created jobs add themselves to <code>Job._all</code> automatically</li>
<li>Jobs know how to convert themselves to JSON for persistence<ul>
<li>Use <code>util.rnd(…)</code> to round values to <code>PRECISION</code> decimal places</li>
</ul>
</li>
</ul>
<pre class=""><code data-file="measure_delay.py">class Job:
    SAVE_KEYS = ["t_create", "t_start", "t_complete"]
    _next_id = count()
    _all = []

    @classmethod
    def reset(cls):
        cls._next_id = count()
        cls._all = []

    def __init__(self, sim):
        Job._all.append(self)
        self.id = next(Job._next_id)
        self.duration = sim.rand_job_duration()
        self.t_create = sim.env.now
        self.t_start = None
        self.t_complete = None

    def json(self):
        return {key: util.rnd(self, key) for key in self.SAVE_KEYS}
</code></pre>
<ul>
<li><code>Simulation</code><ul>
<li>Remember to reset the record of jobs done at the start of the simulation</li>
<li>Otherwise, data from multiple scenarios will pile up</li>
<li>Yes, this is a design smell and we should fix it</li>
</ul>
</li>
</ul>
<pre class=""><code data-file="measure_delay.py">@dataclass
class Simulation(Environment):
    def __init__(self):
        super().__init__()
        self.params = Params()
        self.queue = Store(self)

    def simulate(self):
        Job.reset()
        self.queue = Store(self.env)
        self.env.process(manager(self))
        self.env.process(coder(self))
        self.env.run(until=self.params.t_sim)
</code></pre>
<ul>
<li><code>manager</code> and <code>coder</code> are straightforward</li>
</ul>
<pre class=""><code data-file="measure_delay.py">def manager(sim):
    while True:
        job = Job(sim=sim)
        yield sim.queue.put(job)
        yield sim.env.timeout(sim.rand_job_arrival())


def coder(sim):
    while True:
        job = yield sim.queue.get()
        job.t_start = sim.env.now
        yield sim.env.timeout(job.duration)
        job.t_complete = sim.env.now
</code></pre>
<ul>
<li>Output with default parameters</li>
</ul>
<pre class=""><code data-file="measure_delay.txt">## jobs
shape: (8, 9)
┌──────────┬─────────┬────────────┬─────┬───┬───────────────┬────────────┬───────────┬───────┐
│ t_create ┆ t_start ┆ t_complete ┆ id  ┆ … ┆ t_job_arrival ┆ t_job_mean ┆ t_job_std ┆ t_sim │
│ ---      ┆ ---     ┆ ---        ┆ --- ┆   ┆ ---           ┆ ---        ┆ ---       ┆ ---   │
│ f64      ┆ f64     ┆ f64        ┆ i32 ┆   ┆ f64           ┆ f64        ┆ f64       ┆ i32   │
╞══════════╪═════════╪════════════╪═════╪═══╪═══════════════╪════════════╪═══════════╪═══════╡
│ 0.0      ┆ 0.0     ┆ 0.68       ┆ 0   ┆ … ┆ 2.0           ┆ 0.5        ┆ 0.6       ┆ 10    │
│ 3.12     ┆ 3.12    ┆ 3.99       ┆ 0   ┆ … ┆ 2.0           ┆ 0.5        ┆ 0.6       ┆ 10    │
│ 4.69     ┆ 4.69    ┆ 8.33       ┆ 0   ┆ … ┆ 2.0           ┆ 0.5        ┆ 0.6       ┆ 10    │
│ 5.25     ┆ 8.33    ┆ 9.15       ┆ 0   ┆ … ┆ 2.0           ┆ 0.5        ┆ 0.6       ┆ 10    │
│ 6.87     ┆ 9.15    ┆ null       ┆ 0   ┆ … ┆ 2.0           ┆ 0.5        ┆ 0.6       ┆ 10    │
│ 8.84     ┆ null    ┆ null       ┆ 0   ┆ … ┆ 2.0           ┆ 0.5        ┆ 0.6       ┆ 10    │
│ 9.0      ┆ null    ┆ null       ┆ 0   ┆ … ┆ 2.0           ┆ 0.5        ┆ 0.6       ┆ 10    │
│ 9.37     ┆ null    ┆ null       ┆ 0   ┆ … ┆ 2.0           ┆ 0.5        ┆ 0.6       ┆ 10    │
└──────────┴─────────┴────────────┴─────┴───┴───────────────┴────────────┴───────────┴───────┘
</code></pre>
<ul>
<li>Plot delays for three different simulation durations<ul>
<li>This is what we mean by parameter sweeping</li>
</ul>
</li>
</ul>
<pre class=""><code data-file="measure_delay_sweep.py">if __name__ == "__main__":
    args, results = util.run(Params, Simulation)
    jobs = util.as_frames(results)["jobs"]
    jobs = jobs \
        .filter(pl.col("t_start").is_not_null()) \
        .sort("t_create") \
        .with_columns((pl.col("t_start") - pl.col("t_create")).alias("delay"))
    fig = px.line(jobs, x="t_start", y="delay", facet_col="t_sim")
</code></pre>
<figure id="f:measure_delay_sweep">
<img alt="job delays vs. time" src="measure_delay_sweep.svg"/>
<figcaption>Figure 1: Job delays vs. time</figcaption>
</figure>
<h2>Four Metrics</h2>
<ul>
<li>Reminder that we are interested in:<ul>
<li>Backlog: how much work is waiting to start vs. time?</li>
<li>Delay: how long from job creation to job start?</li>
<li>Throughput: how many jobs are completed per unit time?</li>
<li>Utilization: how busy are the people on the team?</li>
</ul>
</li>
<li>Use classes for processes instead of naked generators<ul>
<li>Gives us a place to store extra data <em>and</em> access it from outside</li>
</ul>
</li>
<li><code>Recorder</code> base class creates unique per-class IDs and saves instances<ul>
<li>A generalization of the machinery we build for the <code>Job</code> class above</li>
<li>Reset IDs and object lists in between parameter sweeps</li>
<li>Expect derived classes to define <code>SAVE_KEYS</code> to identify what to save as JSON</li>
</ul>
</li>
</ul>
<pre class=""><code data-file="four_metrics.py">class Recorder:
    _next_id = defaultdict(count)
    _all = defaultdict(list)

    @staticmethod
    def reset():
        Recorder._next_id = defaultdict(count)
        Recorder._all = defaultdict(list)

    def __init__(self, sim):
        cls = self.__class__
        self.id = next(self._next_id[cls])
        self._all[cls].append(self)
        self.sim = sim

    def json(self):
        return {key: util.rnd(self, key) for key in self.SAVE_KEYS}
</code></pre>
<ul>
<li><code>Manager</code> doesn't really need to be a class, but consistency makes code easier to understand</li>
</ul>
<pre class=""><code data-file="four_metrics.py">class Manager(Recorder):
    def run(self):
        while True:
            job = Job(sim=self.sim)
            yield self.sim.queue.put(job)
            yield self.sim.timeout(self.sim.rand_job_arrival())
</code></pre>
<ul>
<li><code>Coder</code> keeps track of how much time it has spent working</li>
</ul>
<pre class=""><code data-file="four_metrics.py">class Coder(Recorder):
    SAVE_KEYS = ["t_work"]

    def __init__(self, sim):
        super().__init__(sim)
        self.t_work = 0

    def run(self):
        while True:
            job = yield self.sim.queue.get()
            job.t_start = self.sim.now
            yield self.sim.timeout(job.duration)
            job.t_complete = self.sim.now
            self.t_work += job.t_complete - job.t_start
</code></pre>
<ul>
<li><code>Monitor</code> records the length of the queue every few ticks<ul>
<li>SimPy <code>Store</code> keeps items in a list-like object <code>queue.items</code></li>
</ul>
</li>
</ul>
<pre class=""><code data-file="four_metrics.py">class Monitor(Recorder):
    def run(self):
        while True:
            self.sim.lengths.append(
                {"time": self.sim.now, "length": len(self.sim.queue.items)}
            )
            yield self.sim.timeout(self.sim.params.t_monitor)
</code></pre>
<ul>
<li><code>Simulation</code> creates instances <em>and</em> calls their <code>.run()</code> methods<ul>
<li>After resetting all the recording</li>
</ul>
</li>
</ul>
<pre class=""><code data-file="four_metrics.py">class Simulation:
    …
    def run(self):
        Recorder.reset()
        self.queue = Store(self.env)
        self.env.process(Manager(self).run())
        self.env.process(Coder(self).run())
        self.env.process(Monitor(self).run())
        self.env.run(until=self.params.t_sim)
</code></pre>
<ul>
<li>Report results</li>
</ul>
<pre class=""><code data-file="four_metrics.py">class Simulation:
    …
    def result(self):
        return {
            "jobs": [job.json() for job in Recorder._all[Job]],
            "coders": [coder.json() for coder in Recorder._all[Coder]],
            "lengths": self.lengths,
        }
</code></pre>
<ul>
<li>Use <a href="https://pola.rs/">Polars</a> and <a href="https://plotly.com/python/plotly-express/">Plotly Express</a> to analyze and plot</li>
<li>Run the simulation twice each for 200 and 1000 ticks</li>
</ul>
<figure id="f:four_metrics_delay">
<img alt="job delays vs. time" src="four_metrics_delay.svg"/>
<figcaption>Figure 2: Job delays vs. time</figcaption>
</figure>
<figure id="f:four_metrics_backlog">
<img alt="backlog vs. time" src="four_metrics_backlog.svg"/>
<figcaption>Figure 3: Backlog vs. time</figcaption>
</figure>
<div class="row">
<div class="col-6">
<div data-caption="Throughput" id="t:four_metrics_throughput">
<table><caption>Table 1: Throughput</caption>
<thead>
<tr>
<th>id</th>
<th>t_sim</th>
<th>num_jobs</th>
<th>throughput</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>200</td>
<td>96</td>
<td>0.48</td>
</tr>
<tr>
<td>1</td>
<td>200</td>
<td>92</td>
<td>0.46</td>
</tr>
<tr>
<td>2</td>
<td>1000</td>
<td>489</td>
<td>0.49</td>
</tr>
<tr>
<td>3</td>
<td>1000</td>
<td>492</td>
<td>0.49</td>
</tr>
</tbody>
</table>
</div>
</div>
<div class="col-6">
<div data-caption="Utilization" id="t:four_metrics_utilization">
<table><caption>Table 2: Utilization</caption>
<thead>
<tr>
<th>id</th>
<th>t_sim</th>
<th>total_work</th>
<th>utilization</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>200</td>
<td>172.94</td>
<td>0.86</td>
</tr>
<tr>
<td>1</td>
<td>200</td>
<td>175.23</td>
<td>0.88</td>
</tr>
<tr>
<td>2</td>
<td>1000</td>
<td>947.52</td>
<td>0.95</td>
</tr>
<tr>
<td>3</td>
<td>1000</td>
<td>931.92</td>
<td>0.93</td>
</tr>
</tbody>
</table>
</div>
</div>
</div>
<ol>
<li>Backlog and delay track each other pretty closely,
    so we only need to measure one or the other.</li>
<li>Throughput stabilizes right away.
    Utilization takes a little longer,
    but even then the change is pretty small
    as we increase the length of the simulation.</li>
</ol>
<div class="callout">
<p>Imagine you're the manager in the fourth scenario.
You might panic as backlog starts to rise,
not realizing that it's just random variation.</p>
</div>
<h2>Varying Arrival Rate</h2>
<ul>
<li>Vary the job arrival rate from 0.5 to 4.0</li>
</ul>
<figure id="f:job_arrival_wide">
<img alt="backlog vs. time with varying job arrival rates" src="job_arrival_wide.svg"/>
<figcaption>Figure 4: backlog vs. time with varying job arrival rates</figcaption>
</figure>
<ul>
<li>Seems the backlog either grows or doesn't</li>
<li>Zoom in and vary job arrival rate from 1.0 to 2.0</li>
</ul>
<figure id="f:job_arrival_narrow">
<img alt="backlog vs. time with narrower range of job arrival rates" src="job_arrival_narrow.svg"/>
<figcaption>Figure 5: backlog vs. time with narrower range of job arrival rates</figcaption>
</figure>
<ul>
<li>λ (lambda) is the arrival rate: the average number of jobs arriving per unit time</li>
<li>μ (mu) is the service rate: the average number of jobs a single server can serve per unit time</li>
<li>ρ (rho) is the utilization: the fraction of time the server is busy</li>
<li>ρ = λ/μ for single-server systems <em>if λ &lt; μ</em><ul>
<li>If λ ≥ μ, the queue grows without limit</li>
</ul>
</li>
<li>Average waiting time in queue W = ρ/(μ (1-ρ))<ul>
<li>Think of 1-ρ as spare capacity</li>
<li>As the system approaches saturation, waiting times increase rapidly</li>
</ul>
</li>
<li>So if all the programmers are busy 100% of the time,
    the waiting time for new work explodes</li>
<li>There must be slack in the system in order to keep waiting times down</li>
</ul>
<h2>Little's Law</h2>
<ul>
<li>λ (lambda) is the arrival rate</li>
<li>L is the average number of customers in the system</li>
<li>W is average time a customer spends in the system</li>
<li><a href="../glossary/#littles-law">Little's Law</a>: L = λW</li>
<li>Exercise: test this by modifying the simulation to allow multiple coders</li>
</ul>
</main>
<footer>
<div class="row">
<div class="col-3 left">
	  ⇐ <a href="../des/">Discrete Event Simulation</a>
</div>
<div class="col-6 center">
<a href="../"></a>
	  © 2025
	  <a href="../#acknowledgments">the authors</a>
</div>
<div class="col-3 right">
<a href="../scenarios/">Exploring Scenarios</a> ⇒
	</div>
</div>
</footer>
</body>
</html>